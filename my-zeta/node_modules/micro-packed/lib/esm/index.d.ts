import { type Coder as BaseCoder } from '@scure/base';
/**
 * Define complex binary structures using composable primitives.
 * Main ideas:
 * - Encode / decode can be chained, same as in `scure-base`
 * - A complex structure can be created from an array and struct of primitive types
 * - Strings / bytes are arrays with specific optimizations: we can just read bytes directly
 *   without creating plain array first and reading each byte separately.
 * - Types are inferred from definition
 * @module
 * @example
 * import * as P from 'micro-packed';
 * const s = P.struct({
 *   field1: P.U32BE, // 32-bit unsigned big-endian integer
 *   field2: P.string(P.U8), // String with U8 length prefix
 *   field3: P.bytes(32), // 32 bytes
 *   field4: P.array(P.U16BE, P.struct({ // Array of structs with U16BE length
 *     subField1: P.U64BE, // 64-bit unsigned big-endian integer
 *     subField2: P.string(10) // 10-byte string
 *   }))
 * });
 */
/** Shortcut to zero-length (empty) byte array */
export declare const EMPTY: Uint8Array;
/** Shortcut to one-element (element is 0) byte array */
export declare const NULL: Uint8Array;
/** Checks if two Uint8Arrays are equal. Not constant-time. */
declare function equalBytes(a: Uint8Array, b: Uint8Array): boolean;
/** Checks if the given value is a Uint8Array. */
declare function isBytes(a: unknown): a is Bytes;
/**
 * Concatenates multiple Uint8Arrays.
 * Engines limit functions to 65K+ arguments.
 * @param arrays Array of Uint8Array elements
 * @returns Concatenated Uint8Array
 */
declare function concatBytes(...arrays: Uint8Array[]): Uint8Array;
/**
 * Checks if the provided value is a plain object, not created from any class or special constructor.
 * Array, Uint8Array and others are not plain objects.
 * @param obj - The value to be checked.
 */
declare function isPlainObject(obj: any): boolean;
export declare const utils: {
    equalBytes: typeof equalBytes;
    isBytes: typeof isBytes;
    isCoder: typeof isCoder;
    checkBounds: typeof checkBounds;
    concatBytes: typeof concatBytes;
    createView: (arr: Uint8Array) => DataView;
    isPlainObject: typeof isPlainObject;
};
export type Bytes = Uint8Array;
export type Option<T> = T | undefined;
/**
 * Coder encodes and decodes between two types.
 * @property {(from: F) => T} encode - Encodes (converts) F to T
 * @property {(to: T) => F} decode - Decodes (converts) T to F
 */
export interface Coder<F, T> {
    encode(from: F): T;
    decode(to: T): F;
}
/**
 * BytesCoder converts value between a type and a byte array
 * @property {number} [size] - Size hint for the element.
 * @property {(data: T) => Bytes} encode - Encodes a value of type T to a byte array
 * @property {(data: Bytes, opts?: ReaderOpts) => T} decode - Decodes a byte array to a value of type T
 */
export interface BytesCoder<T> extends Coder<T, Bytes> {
    size?: number;
    encode: (data: T) => Bytes;
    decode: (data: Bytes, opts?: ReaderOpts) => T;
}
/**
 * BytesCoderStream converts value between a type and a byte array, using streams.
 * @property {number} [size] - Size hint for the element.
 * @property {(w: Writer, value: T) => void} encodeStream - Encodes a value of type T to a byte array using a Writer stream.
 * @property {(r: Reader) => T} decodeStream - Decodes a byte array to a value of type T using a Reader stream.
 */
export interface BytesCoderStream<T> {
    size?: number;
    encodeStream: (w: Writer, value: T) => void;
    decodeStream: (r: Reader) => T;
}
export type CoderType<T> = BytesCoderStream<T> & BytesCoder<T>;
export type Sized<T> = CoderType<T> & {
    size: number;
};
export type UnwrapCoder<T> = T extends CoderType<infer U> ? U : T;
/**
 * Validation function. Should return value after validation.
 * Can be used to narrow types
 */
export type Validate<T> = (elm: T) => T;
export type Length = CoderType<number> | CoderType<bigint> | number | Bytes | string | null;
type ArrLike<T> = Array<T> | ReadonlyArray<T>;
export type TypedArray = Uint8Array | Int8Array | Uint8ClampedArray | Uint16Array | Int16Array | Uint32Array | Int32Array;
/** Writable version of a type, where readonly properties are made writable. */
export type Writable<T> = T extends {} ? T extends TypedArray ? T : {
    -readonly [P in keyof T]: Writable<T[P]>;
} : T;
export type Values<T> = T[keyof T];
export type NonUndefinedKey<T, K extends keyof T> = T[K] extends undefined ? never : K;
export type NullableKey<T, K extends keyof T> = T[K] extends NonNullable<T[K]> ? never : K;
export type OptKey<T, K extends keyof T> = NullableKey<T, K> & NonUndefinedKey<T, K>;
export type ReqKey<T, K extends keyof T> = T[K] extends NonNullable<T[K]> ? K : never;
export type OptKeys<T> = Pick<T, {
    [K in keyof T]: OptKey<T, K>;
}[keyof T]>;
export type ReqKeys<T> = Pick<T, {
    [K in keyof T]: ReqKey<T, K>;
}[keyof T]>;
export type StructInput<T extends Record<string, any>> = {
    [P in keyof ReqKeys<T>]: T[P];
} & {
    [P in keyof OptKeys<T>]?: T[P];
};
export type StructRecord<T extends Record<string, any>> = {
    [P in keyof T]: CoderType<T[P]>;
};
export type StructOut = Record<string, any>;
/** Padding function that takes an index and returns a padding value. */
export type PadFn = (i: number) => number;
/** Path related utils (internal) */
type Path = {
    obj: StructOut;
    field?: string;
};
type PathStack = Path[];
export type _PathObjFn = (cb: (field: string, fieldFn: Function) => void) => void;
declare const Path: {
    /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */
    pushObj: (stack: PathStack, obj: StructOut, objFn: _PathObjFn) => void;
    path: (stack: PathStack) => string;
    err: (name: string, stack: PathStack, msg: string | Error) => Error;
    resolve: (stack: PathStack, path: string) => StructOut | undefined;
};
/**
 * Options for the Reader class.
 * @property {boolean} [allowUnreadBytes: false] - If there are remaining unparsed bytes, the decoding is probably wrong.
 * @property {boolean} [allowMultipleReads: false] - The check enforces parser termination. If pointers can read the same region of memory multiple times, you can cause combinatorial explosion by creating an array of pointers to the same address and cause DoS.
 */
export type ReaderOpts = {
    allowUnreadBytes?: boolean;
    allowMultipleReads?: boolean;
};
export type Reader = {
    /** Current position in the buffer. */
    readonly pos: number;
    /** Number of bytes left in the buffer. */
    readonly leftBytes: number;
    /** Total number of bytes in the buffer. */
    readonly totalBytes: number;
    /** Checks if the end of the buffer has been reached. */
    isEnd(): boolean;
    /**
     * Creates an error with the given message. Adds information about current field path.
     * If Error object provided, saves original stack trace.
     * @param msg - The error message or an Error object.
     * @returns The created Error object.
     */
    err(msg: string | Error): Error;
    /**
     * Reads a specified number of bytes from the buffer.
     *
     * WARNING: Uint8Array is subarray of original buffer. Do not modify.
     * @param n - The number of bytes to read.
     * @param peek - If `true`, the bytes are read without advancing the position.
     * @returns The read bytes as a Uint8Array.
     */
    bytes(n: number, peek?: boolean): Uint8Array;
    /**
     * Reads a single byte from the buffer.
     * @param peek - If `true`, the byte is read without advancing the position.
     * @returns The read byte as a number.
     */
    byte(peek?: boolean): number;
    /**
     * Reads a specified number of bits from the buffer.
     * @param bits - The number of bits to read.
     * @returns The read bits as a number.
     */
    bits(bits: number): number;
    /**
     * Finds the first occurrence of a needle in the buffer.
     * @param needle - The needle to search for.
     * @param pos - The starting position for the search.
     * @returns The position of the first occurrence of the needle, or `undefined` if not found.
     */
    find(needle: Bytes, pos?: number): number | undefined;
    /**
     * Creates a new Reader instance at the specified offset.
     * Complex and unsafe API: currently only used in eth ABI parsing of pointers.
     * Required to break pointer boundaries inside arrays for complex structure.
     * Please use only if absolutely necessary!
     * @param n - The offset to create the new Reader at.
     * @returns A new Reader instance at the specified offset.
     */
    offsetReader(n: number): Reader;
};
export type Writer = {
    /**
     * Creates an error with the given message. Adds information about current field path.
     * If Error object provided, saves original stack trace.
     * @param msg - The error message or an Error object.
     * @returns The created Error object.
     */
    err(msg: string | Error): Error;
    /**
     * Writes a byte array to the buffer.
     * @param b - The byte array to write.
     */
    bytes(b: Bytes): void;
    /**
     * Writes a single byte to the buffer.
     * @param b - The byte to write.
     */
    byte(b: number): void;
    /**
     * Writes a specified number of bits to the buffer.
     * @param value - The value to write.
     * @param bits - The number of bits to write.
     */
    bits(value: number, bits: number): void;
};
/**
 * Internal structure. Reader class for reading from a byte array.
 * `stack` is internal: for debugger and logging
 * @class Reader
 */
declare class _Reader implements Reader {
    pos: number;
    readonly data: Bytes;
    readonly opts: ReaderOpts;
    readonly stack: PathStack;
    private parent;
    private parentOffset;
    private bitBuf;
    private bitPos;
    private bs;
    private view;
    constructor(data: Bytes, opts?: ReaderOpts, stack?: PathStack, parent?: _Reader | undefined, parentOffset?: number);
    /** Internal method for pointers. */
    _enablePointers(): void;
    private markBytesBS;
    private markBytes;
    pushObj(obj: StructOut, objFn: _PathObjFn): void;
    readView(n: number, fn: (view: DataView, pos: number) => number): number;
    absBytes(n: number): Uint8Array;
    finish(): void;
    err(msg: string | Error): Error;
    offsetReader(n: number): _Reader;
    bytes(n: number, peek?: boolean): Uint8Array;
    byte(peek?: boolean): number;
    get leftBytes(): number;
    get totalBytes(): number;
    isEnd(): boolean;
    bits(bits: number): number;
    find(needle: Bytes, pos?: number): number | undefined;
}
/**
 * Internal structure. Writer class for writing to a byte array.
 * The `stack` argument of constructor is internal, for debugging and logs.
 * @class Writer
 */
declare class _Writer implements Writer {
    pos: number;
    readonly stack: PathStack;
    private buffers;
    ptrs: {
        pos: number;
        ptr: CoderType<number>;
        buffer: Bytes;
    }[];
    private bitBuf;
    private bitPos;
    private viewBuf;
    private view;
    private finished;
    constructor(stack?: PathStack);
    pushObj(obj: StructOut, objFn: _PathObjFn): void;
    writeView(len: number, fn: (view: DataView) => void): void;
    err(msg: string | Error): Error;
    bytes(b: Bytes): void;
    byte(b: number): void;
    finish(clean?: boolean): Bytes;
    bits(value: number, bits: number): void;
}
/** Internal function for checking bit bounds of bigint in signed/unsinged form */
declare function checkBounds(value: bigint, bits: bigint, signed: boolean): void;
/**
 * Validates a value before encoding and after decoding using a provided function.
 * @param inner - The inner CoderType.
 * @param fn - The validation function.
 * @returns CoderType which check value with validation function.
 * @example
 * const val = (n: number) => {
 *   if (n > 10) throw new Error(`${n} > 10`);
 *   return n;
 * };
 *
 * const RangedInt = P.validate(P.U32LE, val); // Will check if value is <= 10 during encoding and decoding
 */
export declare function validate<T>(inner: CoderType<T>, fn: Validate<T>): CoderType<T>;
/**
 * Wraps a stream encoder into a generic encoder and optionally validation function
 * @param {inner} inner BytesCoderStream & { validate?: Validate<T> }.
 * @returns The wrapped CoderType.
 * @example
 * const U8 = P.wrap({
 *   enc